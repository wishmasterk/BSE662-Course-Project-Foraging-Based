% Script generated by Brainstorm (31-Mar-2025)

% IMPORTANT: Before running this script, ensure that the protocol 'TEST_PROTOCOL' is loaded in Brainstorm.
% To load the protocol:
% 1. Open Brainstorm by typing 'brainstorm' in MATLAB.
% 2. Go to File > Load protocol.
% 3. Select 'TEST_PROTOCOL' from the list.
% 4. Click OK.

% Define the input file path
SubjectName = '47131p'; %change the subject name
Condition = '47131'; 
FileName = 'data_block001.mat';
sFiles = {sprintf('%s/%s/%s', SubjectName, Condition, FileName)};

% Start a new report
bst_report('Start', sFiles);

% Process: DC offset correction: [0.000s,5050.996s]
sFiles = bst_process('CallProcess', 'process_baseline', sFiles, [], ...
    'baseline',    [0, 5050.996], ...
    'sensortypes', 'MEG, EEG', ...
    'method',      'bl', ...
    'overwrite',   0);

% Process: Band-pass:0.5Hz-45Hz
sFiles = bst_process('CallProcess', 'process_bandpass', sFiles, [], ...
    'sensortypes', 'MEG, EEG', ...
    'highpass',    0.5, ...
    'lowpass',     45, ...
    'tranband',    0, ...
    'attenuation', 'strict', ...
    'ver',         '2019', ...
    'mirror',      0, ...
    'overwrite',   0);

% Process: Notch filter: 60Hz
sFiles = bst_process('CallProcess', 'process_notch', sFiles, [], ...
    'sensortypes', 'MEG, EEG', ...
    'freqlist',    60, ...
    'cutoffW',     1, ...
    'useold',      0, ...
    'overwrite',   0);

% === Extract markers A→B and B→C ===
% Load .mat file to access events
try
    DataFile = in_bst_data(sFiles(1).FileName);
catch ME
    error('Failed to load data file: %s\nError: %s', sFiles{1}, ME.message);
end

% Get the markers
tB = DataFile.Events(strcmp({DataFile.Events.label}, 'TRIGGER EVENT B')).times(1);
tI = DataFile.Events(strcmp({DataFile.Events.label}, 'TRIGGER EVENT I')).times(1);
tR = DataFile.Events(strcmp({DataFile.Events.label}, 'TRIGGER EVENT R')).times;

% --- Find last R before I ---
R_before_I = tR(tR < tI);
pre_tR = R_before_I(end);
    
% --- Last R overall ---
post_tR = tR(end);

% === Segment 1: B to last R before I ===
fprintf('PreStress: B → last R before I: [%.3f → %.3f] s\n', tB, pre_tR);
Segment1 = bst_process('CallProcess', 'process_extract_time', sFiles, [], ...
    'timewindow', [tB, pre_tR], ...
    'overwrite',  0);

% Load Segment 1 data for sub-segmentation
Segment1_FileName = Segment1(1).FileName;
Segment1_Data = in_bst_data(Segment1_FileName);

% Extract Events for Segment 1
tM1 = sort(Segment1_Data.Events(strcmp({Segment1_Data.Events.label}, 'TRIGGER EVENT M')).times);
tT1 = sort(Segment1_Data.Events(strcmp({Segment1_Data.Events.label}, 'TRIGGER EVENT T')).times);
tU1 = sort(Segment1_Data.Events(strcmp({Segment1_Data.Events.label}, 'TRIGGER EVENT U')).times);

fprintf("\n---PreStress Block (Segment 1)---\n");

% Sub-segmentation for Segment 1: M → (T or U, whichever comes first)
for i = 1:length(tM1)
    % Find the next T or U after current M
    relevantEvents = [tT1(tT1 > tM1(i)), tU1(tU1 > tM1(i))];
    if ~isempty(relevantEvents)
        nextEventTime = min(relevantEvents);
        if ismember(nextEventTime, tT1)
            eventType = 'T';
            fprintf('Segment - M%d → T: [%.3f → %.3f] s\n', i, tM1(i), nextEventTime);
            SubSegment = bst_process('CallProcess', 'process_extract_time', {Segment1_FileName}, [], ...
                'timewindow', [tM1(i), nextEventTime], ...
                'overwrite', 0, ...
                'outputname', sprintf('PreStress_M%d_T', i));
               
        elseif ismember(nextEventTime, tU1)
            eventType = 'U';
            fprintf('Segment - M%d → U: [%.3f → %.3f] s\n', i, tM1(i), nextEventTime);
            SubSegment = bst_process('CallProcess', 'process_extract_time', {Segment1_FileName}, [], ...
                'timewindow', [tM1(i), nextEventTime], ...
                'overwrite', 0, ...
                'outputname', sprintf('PreStress_M%d_U', i));
        end
    else
        warning('No T or U after M%d in PreStress Block — skipping this pair.', i);
    end
end

fprintf('\n---Running PSD + FOOOF for PreStress---\n');
studyInfo = bst_get('Study', Segment1(1).iStudy);
for i = 6:length(studyInfo.Data)
    subsegFile = studyInfo.Data(i).FileName;

    PSD = bst_process('CallProcess', 'process_psd', {subsegFile}, [], ...
        'timewindow', [], ...
        'win_length',  1, ...
            'win_overlap', 50, ...
            'units',       'physical', ...  % Physical: U2/Hz
            'sensortypes', 'MEG, EEG', ...
            'win_std',     0, ...
            'edit',        struct(...
                 'Comment',         'Power', ...
                 'TimeBands',       [], ...
                 'Freqs',           [], ...
                 'ClusterFuncTime', 'none', ...
                 'Measure',         'power', ...
                 'Output',          'all', ...
                 'SaveKernel',      0));

    bst_process('CallProcess', 'process_fooof', PSD, [], ...
    'implementation', 'matlab', ...       % Use internal MATLAB implementation
    'freqrange',      [1, 50], ...        % Analyze full range covering all canonical bands
    'powerline',      'None', ...         % No powerline noise removal here (do it earlier if needed)
    'method',         'leastsquare', ...  % Standard FOOOF method (you can also try 'montecarlo')
    'peakwidth',      [0.5, 12], ...      % Minimum and maximum full width at half max (FWHM) of peaks
    'maxpeaks',       6, ...              % Max peaks to model; 6 ensures it tries to model multiple bands
    'minpeakheight',  0.1, ...            % Lower threshold to ensure weaker peaks (like theta) are not ignored
    'proxthresh',     2, ...              % Minimum distance between peak centers in Hz
    'apermode',       'fixed', ...        % ‘fixed’ = y-intercept and slope, no knee (good for EEG)
    'guessweight',    'none', ...         % Disable weight adjustment during model guessing
    'sorttype',       'param', ...        % Sort based on peak characteristics (not band proximity)
    'sortparam',      'height', ...       % Prioritize tallest peaks (you can also try 'std')
    'sortbands', { ...
        'delta',  '2, 4'; ...
        'theta',  '4, 7'; ...
        'alpha',  '8, 12'; ...
        'beta',   '15, 29'; ...
        'gamma1', '30, 50' });            % gamma2 up to 90 Hz excluded since freqrange stops at 50
end

% === Segment 2: I to last R overall ===
fprintf('PostStress: I → last R: [%.3f → %.3f] s\n', tI, post_tR);
Segment2 = bst_process('CallProcess', 'process_extract_time', sFiles, [], ...
    'timewindow', [tI, post_tR], ...
    'overwrite', 0);

% Load Segment 2 data for sub-segmentation
Segment2_FileName = Segment2(1).FileName;
Segment2_Data = in_bst_data(Segment2_FileName);

% Extract Events for Segment 2
tM2 = sort(Segment2_Data.Events(strcmp({Segment2_Data.Events.label}, 'TRIGGER EVENT M')).times);
tT2 = sort(Segment2_Data.Events(strcmp({Segment2_Data.Events.label}, 'TRIGGER EVENT T')).times);
tU2 = sort(Segment2_Data.Events(strcmp({Segment2_Data.Events.label}, 'TRIGGER EVENT U')).times);

fprintf("\n---PostStress Block (Segment 2)---\n");

% Sub-segmentation for Segment 2: M → (T or U, whichever comes first)
for i = 1:length(tM2)
    % Find the next T or U after current M
    relevantEvents = [tT2(tT2 > tM2(i)), tU2(tU2 > tM2(i))];
    if ~isempty(relevantEvents)
        nextEventTime = min(relevantEvents);
        if ismember(nextEventTime, tT2)
            eventType = 'T';
            fprintf('Segment - M%d → T: [%.3f → %.3f] s\n', i, tM2(i), nextEventTime);
            SubSegment = bst_process('CallProcess', 'process_extract_time', {Segment2_FileName}, [], ...
                'timewindow', [tM2(i), nextEventTime], ...
                'overwrite', 0, ...
                'outputname', sprintf('PostStress_M%d_T', i));

        elseif ismember(nextEventTime, tU2)
            eventType = 'U';
            fprintf('Segment - M%d → U: [%.3f → %.3f] s\n', i, tM2(i), nextEventTime);
            SubSegment = bst_process('CallProcess', 'process_extract_time', {Segment2_FileName}, [], ...
                'timewindow', [tM2(i), nextEventTime], ...
                'overwrite', 0, ...
                'outputname', sprintf('PostStress_M%d_U', i));
        end
    else
        warning('No T or U after M%d in PostStress Block — skipping this pair.', i);
    end
end

fprintf('\n---Running PSD + FOOOF for PostStress---\n');
studyInfo2 = bst_get('Study', Segment2(1).iStudy);
for i = 2 + length(studyInfo.Data):length(studyInfo2.Data)
    subsegFile = studyInfo2.Data(i).FileName;
    PSD = bst_process('CallProcess', 'process_psd', {subsegFile}, [], ...
        'timewindow', [], ...
        'win_length',  1, ...
            'win_overlap', 50, ...
            'units',       'physical', ...  % Physical: U2/Hz
            'sensortypes', 'MEG, EEG', ...
            'win_std',     0, ...
            'edit',        struct(...
                 'Comment',         'Power', ...
                 'TimeBands',       [], ...
                 'Freqs',           [], ...
                 'ClusterFuncTime', 'none', ...
                 'Measure',         'power', ...
                 'Output',          'all', ...
                 'SaveKernel',      0));

    bst_process('CallProcess', 'process_fooof', PSD, [], ...
    'implementation', 'matlab', ...       % Use internal MATLAB implementation
    'freqrange',      [1, 50], ...        % Analyze full range covering all canonical bands
    'powerline',      'None', ...         % No powerline noise removal here (do it earlier if needed)
    'method',         'leastsquare', ...  % Standard FOOOF method (you can also try 'montecarlo')
    'peakwidth',      [0.5, 12], ...      % Minimum and maximum full width at half max (FWHM) of peaks
    'maxpeaks',       6, ...              % Max peaks to model; 6 ensures it tries to model multiple bands
    'minpeakheight',  0.1, ...            % Lower threshold to ensure weaker peaks (like theta) are not ignored
    'proxthresh',     2, ...              % Minimum distance between peak centers in Hz
    'apermode',       'fixed', ...        % ‘fixed’ = y-intercept and slope, no knee (good for EEG)
    'guessweight',    'none', ...         % Disable weight adjustment during model guessing
    'sorttype',       'param', ...        % Sort based on peak characteristics (not band proximity)
    'sortparam',      'height', ...       % Prioritize tallest peaks (you can also try 'std')
    'sortbands', { ...
        'delta',  '2, 4'; ...
        'theta',  '4, 7'; ...
        'alpha',  '8, 12'; ...
        'beta',   '15, 29'; ...
        'gamma1', '30, 50' });            % gamma2 up to 90 Hz excluded since freqrange stops at 50
end

% === Finalize and Open Report ===
ReportFile = bst_report('Save', sFiles);
bst_report('Open', ReportFile);